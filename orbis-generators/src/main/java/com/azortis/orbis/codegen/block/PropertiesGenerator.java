/*
 * A dynamic data-driven world generator plugin/library for Minecraft servers.
 *     Copyright (C) 2021  Azortis
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package com.azortis.orbis.codegen.block;

import com.azortis.orbis.codegen.OrbisCodeGenerator;
import com.google.common.collect.ImmutableMap;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.TypeSpec;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Map;

public class PropertiesGenerator extends OrbisCodeGenerator {
    private static final Logger LOGGER = LoggerFactory.getLogger(PropertiesGenerator.class);
    private static final ImmutableMap<String, String> rewrites; // Mapping certain names
    private static final ImmutableMap<String, String> enumClasses;

    static {
        ImmutableMap.Builder<String, String> builder = ImmutableMap.builder();
        builder.put("ROTATION_16", "ROTATION");
        builder.put("MODE_COMPARATOR", "COMPARATOR_MODE");
        builder.put("STRUCTUREBLOCK_MODE", "STRUCTURE_BLOCK_MODE");
        rewrites = builder.build();

        builder = ImmutableMap.builder();

        enumClasses = builder.build();
    }

    public PropertiesGenerator(InputStream inputStream, File outputFolder) {
        super(inputStream, outputFolder);
    }

    @Override
    public void generate() {
        if(this.inputStream == null){
            LOGGER.error("Failed to find properties data file");
            return;
        }
        if(!outputFolder.exists() && !outputFolder.mkdirs()){
            LOGGER.error("Output folder doesn't exist and failed to create it!");
            return;
        }

        JsonObject properties = GSON.fromJson(new InputStreamReader(inputStream), JsonObject.class);

        // Property types
        ClassName booleanProperty = ClassName.get("com.azortis.orbis.block.property", "BooleanProperty");
        ClassName integerProperty = ClassName.get("com.azortis.orbis.block.property", "IntegerProperty");
        ClassName enumProperty = ClassName.get("com.azortis.orbis.block.property", "EnumProperty");

        // Class to write to
        ClassName propertiesClassName = ClassName.get("com.azortis.orbis.block.property", "Properties");
        TypeSpec.Builder propertiesClass = TypeSpec.classBuilder(propertiesClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL).addJavadoc("This class has been autogenerated.");

        for (Map.Entry<String, JsonElement> entry : properties.entrySet()){
            final String propertyName = getPropertyName(entry.getKey());
            final JsonObject propertyObject = entry.getValue().getAsJsonObject();

            String key = propertyObject.get("key").getAsString();
            JsonArray values = propertyObject.getAsJsonArray("values");

            if(!propertyObject.has("enumMojangName")){
                JsonPrimitive primitive = values.get(0).getAsJsonPrimitive();

                if(primitive.isBoolean()){
                    propertiesClass.addField(
                            FieldSpec.builder(booleanProperty, propertyName)
                                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC)
                                    .addAnnotation(NotNull.class)
                                    .initializer("$T.create($S);", booleanProperty, key).build());
                } else {
                    int min = values.get(0).getAsInt();
                    int max = values.get((values.size() - 1)).getAsInt();
                    propertiesClass.addField(
                            FieldSpec.builder(integerProperty, propertyName)
                                    .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC)
                                    .addAnnotation(NotNull.class)
                                    .initializer("$T.create($S,$L,$L);", integerProperty, min, max)
                                    .build());
                }
            } else {

            }
        }
    }

    private ClassName getEnumClass(String mojangEnum){
        return null;
    }

    private String getPropertyName(String mojangPropertyName){
        if(rewrites.containsKey(mojangPropertyName))return rewrites.get(mojangPropertyName);
        return mojangPropertyName;
    }

}
